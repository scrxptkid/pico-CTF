# heap 0

## Overview:
* Binary Exploitation
* Easy
* heap

## Description:
Are overflows just a stack concern? Download the binary [here](https://artifacts.picoctf.net/c_tethys/15/chall). Download the source [here](https://artifacts.picoctf.net/c_tethys/15/chall.c).

## Write-up:
First, download the binary and the source.

It's a simple buffer overflow task, let's see the source code:
```c
#define FLAGSIZE_MAX 64
// amount of memory allocated for input_data
#define INPUT_DATA_SIZE 5
// amount of memory allocated for safe_var
#define SAFE_VAR_SIZE 5

int num_allocs;
char *safe_var;
char *input_data;

void check_win() {
    if (strcmp(safe_var, "bico") != 0) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

```
strcpm(safe_var, "bico") comparing two strings: safe_var and bico, if they identical it returns 0. In source code to win you need strcmp() return not zero. 

To do so, we need to cause buffer overflow:
```
Data for buffer: 123123123123123123123123123123123123123123123123123123123123
```
Then, type 4 and the program will print you the flag.

## Flag
```
picoCTF{my_first_heap_overflow_0c473fe8}
```
